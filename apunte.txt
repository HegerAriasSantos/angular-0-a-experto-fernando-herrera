flag importantes:
--skipsTests for skip tests

notes:
- ordenamiento de imports:
  - importaciones de angular
  - importaciones de terceros
  - importaciones de la app


Minimalist Angular Cli generate example

ng g c hero-component --flat -it -is --skipTests

-is         for inline css, preventing style file creation
--flat      to prevent folder creation
-it         for inline template, preventing html file creation
--skipTests to prevent .spec file creation


Cositas de angular:

- viewChild es para obtener una referencia a un elemento del DOM
- ng-content es para insertar contenido en un componente
- ng-template es para crear un template que se puede usar en cualquier parte de la app
- ng-container es para crear un elemento que no se renderiza en el DOM
- ngIf es para renderizar un elemento si una condición es verdadera
- ngFor es para iterar sobre un array y renderizar un elemento por cada elemento del array
- ngSwitch es para renderizar un elemento dependiendo de una condición
- ngClass es para agregar clases a un elemento dependiendo de una condición
- ngStyle es para agregar estilos a un elemento dependiendo de una condición
- ngModel es para hacer dos way data binding
- ngModelGroup es para agrupar elementos de un formulario
- ngForm es para crear un formulario
- ngSubmit es para ejecutar una función cuando se envía un formulario
- ngNonBindable es para evitar que angular compile un elemento
- ngProjectAs es para renombrar un elemento
- ngTemplateOutlet es para renderizar un template
- ngValue es para asignar un valor a un elemento
- ngModelOptions es para configurar el comportamiento de ngModel
- ngPlural es para renderizar un elemento dependiendo de la cantidad de un elemento
- ngPluralCase es para renderizar un elemento dependiendo de la cantidad de un elemento
- ngTemplateOutletContext es para pasar un contexto a un template
- ngTransclude es para insertar contenido en un componente
- ngModelChange es para ejecutar una función cuando el valor de un elemento cambia

angular router:

- routerLink es para navegar a una ruta
- routerLinkActive es para agregar una clase a un elemento cuando se navega a una ruta
- routerLinkActiveOptions es para configurar el comportamiento de routerLinkActive


pipes:

- async es para subscribirse a un observable
- date es para formatear una fecha
- uppercase es para convertir un texto a mayúsculas
- lowercase es para convertir un texto a minúsculas
- currency es para formatear un número como moneda
- decimal es para formatear un número como decimal
- percent es para formatear un número como porcentaje
- slice es para cortar un texto
- json es para convertir un objeto a json
- titlecase es para convertir un texto a title case
- i18nPlural es para formatear un texto dependiendo de la cantidad de un elemento
- i18nSelect es para formatear un texto dependiendo de un valor
- number es para formatear un número
- percent es para formatear un número como porcentaje
- currency es para formatear un número como moneda


pipes personalizados:

- para crear un pipe personalizado se necesita crear una clase que implemente PipeTransform y dentro de la clase se debe implementar el método transform, el cual recive por parametros el valor a transformar y los parametros del pipe, por ejemplo:

@Pipe({
  name: 'customPipe'
})
export class CustomPipe implements PipeTransform {
  transform(value: any, ...args: any[]): any {
    return value + 'custom';
  }
}

routes:

- para crear una ruta se debe crear un objeto de tipo Routes y dentro de este objeto se deben crear objetos de tipo Route, cada objeto de tipo Route debe tener un path y un componente, por ejemplo:

const routes: Routes = [
  {
    path: 'home',
    component: HomeComponent
  },
  {
    path: '**', // esto se usa para cuando no se encuentra la ruta
    redirectTo: 'home'
  }
];


routes hijas:

- para crear rutas hijas se debe crear un objeto de tipo Routes y dentro de este objeto se deben crear objetos de tipo Route, cada objeto de tipo Route debe tener un path y un children, el children debe ser un objeto de tipo Routes, por ejemplo:

const routes: Routes = [
  {
    path: 'home',
    component: HomeComponent,
    children: [
      {
        path: 'child',
        component: ChildComponent
      }
    ]
  },
  {
    path: '**', // esto se usa para cuando no se encuentra la ruta
    redirectTo: 'home'
  }
];

routa con lazy loading:

- para crear una ruta con lazy loading se debe crear un objeto de tipo Routes y dentro de este objeto se deben crear objetos de tipo Route, cada objeto de tipo Route debe tener un path y un loadChildren, el loadChildren debe ser un string que contenga el path del modulo que se quiere cargar, por ejemplo:

const routes: Routes = [
  {
    path: 'home',
    component: HomeComponent,
    children: [
      {
        path: 'child',
        component: ChildComponent
      }
    ]
  },
  {
    path: 'lazy',
    loadChildren: () => import('./lazy/lazy.module').then(m => m.LazyModule) // esto sirve para cargar el modulo lazy, ojo se cargan los hijos de esa ruta base.
  },
  {
    path: '**', // esto se usa para cuando no se encuentra la ruta
    redirectTo: 'home'
  }
];


Rutas Protegidas:

- para crear rutas protegidas se debe crear un objeto de tipo Routes y dentro de este objeto se deben crear objetos de tipo Route, cada objeto de tipo Route debe tener un path y un canActivate, el canActivate debe ser un array de clases que implementen CanActivate, por ejemplo:




Guards:

- CanActivate es para proteger una ruta, si el guard retorna true se puede navegar a la ruta, si retorna false no se puede navegar a la ruta.

- CanActivateChild es para proteger las rutas hijas, si el guard retorna true se puede navegar a la ruta, si retorna false no se puede navegar a la ruta.

- CanDeactivate es para proteger una ruta cuando se quiere salir de ella, si el guard retorna true se puede salir de la ruta, si retorna false no se puede salir de la ruta.

- Resolve es para resolver datos antes de cargar una ruta, si el guard retorna true se puede cargar la ruta, si retorna false no se puede cargar la ruta.

- CanLoad es para proteger una ruta con lazy loading, si el guard retorna true se puede cargar la ruta, si retorna false no se puede cargar la ruta.

- CanLoadChild es para proteger las rutas hijas con lazy loading, si el guard retorna true se puede cargar la ruta, si retorna false no se puede cargar la ruta.

- CanReuse es para reutilizar una ruta, si el guard retorna true se puede reutilizar la ruta, si retorna false no se puede reutilizar la ruta.

- CanDeactivateGuard es para proteger una ruta cuando se quiere salir de ella, si el guard retorna true se puede salir de la ruta, si retorna false no se puede salir de la ruta.

- CanActivateGuard es para proteger una ruta, si el guard retorna true se puede navegar a la ruta, si retorna false no se puede navegar a la ruta.

- CanActivateChildGuard es para proteger las rutas hijas, si el guard retorna true se puede navegar a la ruta, si retorna false no se puede navegar a la ruta.

- CanLoadGuard es para proteger una ruta con lazy loading, si el guard retorna true se puede cargar la ruta, si retorna false no se puede cargar la ruta.

- CanLoadChildGuard es para proteger las rutas hijas con lazy loading, si el guard retorna true se puede cargar la ruta, si retorna false no se puede cargar la ruta.

- CanReuseGuard es para reutilizar una ruta, si el guard retorna true se puede reutilizar la ruta, si retorna false no se puede reutilizar la ruta.

- ResolveGuard es para resolver datos antes de cargar una ruta, si el guard retorna true se puede cargar la ruta, si retorna false no se puede cargar la ruta.


Implementacion del guard:

- basicamente para implementar un guard debemos crear una clase que implemente CanActivate, CanActivateChild, CanDeactivate, Resolve, CanLoad, CanLoadChild, CanReuse, por ejemplo:

import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class CanActivateGuard implements CanActivate {
  canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    return true;
  }
}


Implementacion del guard en la ruta:

- para implementar el guard en la ruta debemos crear un objeto de tipo Routes y dentro de este objeto se deben crear objetos de tipo Route, cada objeto de tipo Route debe tener un path y un canActivate, el canActivate debe ser un array de clases que implementen CanActivate, por ejemplo:

const routes: Routes = [
  {
    path: 'home',
    component: HomeComponent,
    canLoad: [CanActivateGuard], // aqui se pueden pasar tantos guards como queramos para asignarles reglas para poder cargar la ruta
    children: [
      {
        path: 'child',
        component: ChildComponent
      }
    ]
  },
  {
    path: 'lazy',
    loadChildren: () => import('./lazy/lazy.module').then(m => m.LazyModule) // esto sirve para cargar el modulo lazy, ojo se cargan los hijos de esa ruta base.
  },
  {
    path: '**', // esto se usa para cuando no se encuentra la ruta
    redirectTo: 'home'
  }
];


Directives:

- las directivas son clases que se pueden usar en el html, por ejemplo:

import { Directive, ElementRef } from '@angular/core';

@Directive({
  selector: '[error-msg]'
})

export class ErrorMsgDirective {
  element: ElementRef;
  @Input() color: string = 'red';
  constructor(private el: ElementRef) {
    element = el;
  }
  ngOnInit() {
    this.setColor();
  }
  setColor() {
    this.element.nativeElement.style.color = color;
  }
}


Directivas estructurales:

- las directivas estructurales son directivas que se pueden usar en el html para modificar el html, por ejemplo:

import { Directive, Input, Templateref, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[customIf]'
})

export class CustomIfDirective {
  @Input() set customIf(condition: boolean) {
    if (condition) {
      this.viewContainer.createEmbeddedView(this.templateRef);
    } else {
      this.viewContainer.clear();
    }
  }
  constructor(private templateRef: TemplateRef<any>, private viewContainer: ViewContainerRef) {}
}

datos curiosos

- con # se hace referencia a un elemento del html
- con * se hace referencia a todo el componente html


async validator:
- un async validator es un validator que se ejecuta de forma asincrona, el cual es basicamente un servicio que implementa la interfaz AsyncValidator, por ejemplo: 

import { Injectable } from '@angular/core';
import { AsyncValidator, AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { UserService } from '../services/user.service';


@injectable({
  providedIn: 'root'
})

export class UserValidator implements AsyncValidator {
  constructor(private userService: UserService) {}
  validate(control: AbstractControl): Observable<ValidationErrors | null> {
    return this.userService.getUser(control.value).pipe(
      map(user => {
        return user ? { userExists: true } : null;
      })
    );
  }
}
